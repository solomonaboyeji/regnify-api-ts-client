/* tslint:disable */
/* eslint-disable */
/**
 * REGNIFY HTTP API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Contact: admin@regnify.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'token_type'?: string;
}
/**
 * 
 * @export
 * @interface AppResponseModel
 */
export interface AppResponseModel {
    /**
     * 
     * @type {string}
     * @memberof AppResponseModel
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface BodyEditRoleRolesRoleIdPut
 */
export interface BodyEditRoleRolesRoleIdPut {
    /**
     * 
     * @type {string}
     * @memberof BodyEditRoleRolesRoleIdPut
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BodyEditRoleRolesRoleIdPut
     */
    'permissions': Array<string>;
}
/**
 * 
 * @export
 * @interface ChangePassword
 */
export interface ChangePassword {
    /**
     * 
     * @type {string}
     * @memberof ChangePassword
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ChangePasswordWithToken
 */
export interface ChangePasswordWithToken {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordWithToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordWithToken
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface ManyRolesOut
 */
export interface ManyRolesOut {
    /**
     * 
     * @type {Array<RoleOut>}
     * @memberof ManyRolesOut
     */
    'roles': Array<RoleOut>;
    /**
     * 
     * @type {number}
     * @memberof ManyRolesOut
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ManySystemScopeOut
 */
export interface ManySystemScopeOut {
    /**
     * 
     * @type {Array<SystemScopeOut>}
     * @memberof ManySystemScopeOut
     */
    'scopes': Array<SystemScopeOut>;
}
/**
 * 
 * @export
 * @interface ManyUserRolesOut
 */
export interface ManyUserRolesOut {
    /**
     * 
     * @type {number}
     * @memberof ManyUserRolesOut
     */
    'total': number;
    /**
     * 
     * @type {Array<UserRoleOut>}
     * @memberof ManyUserRolesOut
     */
    'user_roles': Array<UserRoleOut>;
}
/**
 * 
 * @export
 * @interface ManyUsersInDB
 */
export interface ManyUsersInDB {
    /**
     * 
     * @type {number}
     * @memberof ManyUsersInDB
     */
    'total'?: number;
    /**
     * 
     * @type {Array<UserOut>}
     * @memberof ManyUsersInDB
     */
    'data': Array<UserOut>;
}
/**
 * 
 * @export
 * @interface MiniFileObjectOut
 */
export interface MiniFileObjectOut {
    /**
     * 
     * @type {string}
     * @memberof MiniFileObjectOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MiniFileObjectOut
     */
    'original_file_name': string;
}
/**
 * 
 * @export
 * @interface MiniRoleOut
 */
export interface MiniRoleOut {
    /**
     * 
     * @type {string}
     * @memberof MiniRoleOut
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MiniRoleOut
     */
    'permissions': Array<string>;
}
/**
 * 
 * @export
 * @interface MiniUserRoleOut
 */
export interface MiniUserRoleOut {
    /**
     * 
     * @type {MiniRoleOut}
     * @memberof MiniUserRoleOut
     */
    'role': MiniRoleOut;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const OrderBy = {
    Created: 'DATE_CREATED',
    Modified: 'DATE_MODIFIED'
} as const;

export type OrderBy = typeof OrderBy[keyof typeof OrderBy];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const OrderDirection = {
    Desc: 'DESC',
    Asc: 'ASC'
} as const;

export type OrderDirection = typeof OrderDirection[keyof typeof OrderDirection];


/**
 * 
 * @export
 * @interface ProfileOut
 */
export interface ProfileOut {
    /**
     * 
     * @type {string}
     * @memberof ProfileOut
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileOut
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileOut
     */
    'avatar_url': string;
    /**
     * 
     * @type {MiniFileObjectOut}
     * @memberof ProfileOut
     */
    'photo_file'?: MiniFileObjectOut;
}
/**
 * 
 * @export
 * @interface RoleCreate
 */
export interface RoleCreate {
    /**
     * 
     * @type {string}
     * @memberof RoleCreate
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleCreate
     */
    'permissions': Array<string>;
}
/**
 * 
 * @export
 * @interface RoleOut
 */
export interface RoleOut {
    /**
     * 
     * @type {string}
     * @memberof RoleOut
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RoleOut
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleOut
     */
    'permissions': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof RoleOut
     */
    'can_be_deleted': boolean;
    /**
     * 
     * @type {UserOut}
     * @memberof RoleOut
     */
    'created_by_user': UserOut;
    /**
     * 
     * @type {UserOut}
     * @memberof RoleOut
     */
    'modified_by_user'?: UserOut;
    /**
     * 
     * @type {string}
     * @memberof RoleOut
     */
    'date_created': string;
    /**
     * 
     * @type {string}
     * @memberof RoleOut
     */
    'date_modified'?: string;
}
/**
 * 
 * @export
 * @interface SystemScopeOut
 */
export interface SystemScopeOut {
    /**
     * 
     * @type {string}
     * @memberof SystemScopeOut
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemScopeOut
     */
    'scopes': Array<string>;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'access_begin'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'access_end'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreate
     */
    'is_super_admin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserOut
 */
export interface UserOut {
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'access_begin'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'access_end'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserOut
     */
    'is_active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserOut
     */
    'is_super_admin': boolean;
    /**
     * 
     * @type {Array<MiniUserRoleOut>}
     * @memberof UserOut
     */
    'user_roles': Array<MiniUserRoleOut>;
    /**
     * 
     * @type {ProfileOut}
     * @memberof UserOut
     */
    'profile': ProfileOut;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'last_login'?: string;
}
/**
 * 
 * @export
 * @interface UserRoleOut
 */
export interface UserRoleOut {
    /**
     * 
     * @type {RoleOut}
     * @memberof UserRoleOut
     */
    'role': RoleOut;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'is_super_admin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'last_login'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'access_begin'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'access_end'?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticates with the given credentials.  **Note**, passwords are case sensitive.
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('login', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('login', 'password', password)
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticates with the given credentials.  **Note**, passwords are case sensitive.
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Authenticates with the given credentials.  **Note**, passwords are case sensitive.
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.login(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Authenticates with the given credentials.  **Note**, passwords are case sensitive.
     * @summary Login
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolesAndPermissionsApi - axios parameter creator
 * @export
 */
export const RolesAndPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns the role to the specified user.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:create, me,  
         * @summary Assign Role
         * @param {string} roleId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRole: async (roleId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('assignRole', 'roleId', roleId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignRole', 'userId', userId)
            const localVarPath = `/roles/{role_id}/assign-role`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows an admin to create a role in the system.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:create, me,  
         * @summary Create Role
         * @param {RoleCreate} roleCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (roleCreate: RoleCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleCreate' is not null or undefined
            assertParamExists('createRole', 'roleCreate', roleCreate)
            const localVarPath = `/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the role. This endpoint removes the roles from all users that has been previously assigned. The integer returned is the total number of all users the role has been removed from.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:delete, me,  
         * @summary Delete Role
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (roleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteRole', 'roleId', roleId)
            const localVarPath = `/roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a single role                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:update, me,  
         * @summary Edit Role
         * @param {string} roleId 
         * @param {BodyEditRoleRolesRoleIdPut} bodyEditRoleRolesRoleIdPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRole: async (roleId: string, bodyEditRoleRolesRoleIdPut: BodyEditRoleRolesRoleIdPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('editRole', 'roleId', roleId)
            // verify required parameter 'bodyEditRoleRolesRoleIdPut' is not null or undefined
            assertParamExists('editRole', 'bodyEditRoleRolesRoleIdPut', bodyEditRoleRolesRoleIdPut)
            const localVarPath = `/roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyEditRoleRolesRoleIdPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single role                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:read, me,  
         * @summary Get Role
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (roleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getRole', 'roleId', roleId)
            const localVarPath = `/roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all the roles in the system                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:read, me,  
         * @summary Get Roles
         * @param {OrderBy} [orderBy] 
         * @param {OrderDirection} [orderDirection] 
         * @param {string} [title] 
         * @param {string} [query] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles: async (orderBy?: OrderBy, orderDirection?: OrderDirection, title?: string, query?: string, skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['order_direction'] = orderDirection;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the users that are assigned to a particular role.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:read, me,  
         * @summary List Users Assigned To Role
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersAssignedToRole: async (roleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('listUsersAssignedToRole', 'roleId', roleId)
            const localVarPath = `/roles/{role_id}/list-assigned-users`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unassign the role to the specified user.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:create, me,  
         * @summary Unassign Role
         * @param {string} roleId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignRole: async (roleId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('unassignRole', 'roleId', roleId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('unassignRole', 'userId', userId)
            const localVarPath = `/roles/{role_id}/unassign-role`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesAndPermissionsApi - functional programming interface
 * @export
 */
export const RolesAndPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesAndPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Assigns the role to the specified user.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:create, me,  
         * @summary Assign Role
         * @param {string} roleId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignRole(roleId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignRole(roleId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows an admin to create a role in the system.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:create, me,  
         * @summary Create Role
         * @param {RoleCreate} roleCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(roleCreate: RoleCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(roleCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the role. This endpoint removes the roles from all users that has been previously assigned. The integer returned is the total number of all users the role has been removed from.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:delete, me,  
         * @summary Delete Role
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(roleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a single role                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:update, me,  
         * @summary Edit Role
         * @param {string} roleId 
         * @param {BodyEditRoleRolesRoleIdPut} bodyEditRoleRolesRoleIdPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editRole(roleId: string, bodyEditRoleRolesRoleIdPut: BodyEditRoleRolesRoleIdPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editRole(roleId, bodyEditRoleRolesRoleIdPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a single role                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:read, me,  
         * @summary Get Role
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(roleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all the roles in the system                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:read, me,  
         * @summary Get Roles
         * @param {OrderBy} [orderBy] 
         * @param {OrderDirection} [orderDirection] 
         * @param {string} [title] 
         * @param {string} [query] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoles(orderBy?: OrderBy, orderDirection?: OrderDirection, title?: string, query?: string, skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManyRolesOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoles(orderBy, orderDirection, title, query, skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the users that are assigned to a particular role.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:read, me,  
         * @summary List Users Assigned To Role
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersAssignedToRole(roleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManyUserRolesOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersAssignedToRole(roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unassign the role to the specified user.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:create, me,  
         * @summary Unassign Role
         * @param {string} roleId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unassignRole(roleId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unassignRole(roleId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolesAndPermissionsApi - factory interface
 * @export
 */
export const RolesAndPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesAndPermissionsApiFp(configuration)
    return {
        /**
         * Assigns the role to the specified user.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:create, me,  
         * @summary Assign Role
         * @param {string} roleId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRole(roleId: string, userId: string, options?: any): AxiosPromise<UserOut> {
            return localVarFp.assignRole(roleId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows an admin to create a role in the system.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:create, me,  
         * @summary Create Role
         * @param {RoleCreate} roleCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(roleCreate: RoleCreate, options?: any): AxiosPromise<RoleOut> {
            return localVarFp.createRole(roleCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the role. This endpoint removes the roles from all users that has been previously assigned. The integer returned is the total number of all users the role has been removed from.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:delete, me,  
         * @summary Delete Role
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(roleId: string, options?: any): AxiosPromise<AppResponseModel> {
            return localVarFp.deleteRole(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a single role                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:update, me,  
         * @summary Edit Role
         * @param {string} roleId 
         * @param {BodyEditRoleRolesRoleIdPut} bodyEditRoleRolesRoleIdPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editRole(roleId: string, bodyEditRoleRolesRoleIdPut: BodyEditRoleRolesRoleIdPut, options?: any): AxiosPromise<RoleOut> {
            return localVarFp.editRole(roleId, bodyEditRoleRolesRoleIdPut, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a single role                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:read, me,  
         * @summary Get Role
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(roleId: string, options?: any): AxiosPromise<RoleOut> {
            return localVarFp.getRole(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all the roles in the system                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:read, me,  
         * @summary Get Roles
         * @param {OrderBy} [orderBy] 
         * @param {OrderDirection} [orderDirection] 
         * @param {string} [title] 
         * @param {string} [query] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(orderBy?: OrderBy, orderDirection?: OrderDirection, title?: string, query?: string, skip?: number, limit?: number, options?: any): AxiosPromise<ManyRolesOut> {
            return localVarFp.getRoles(orderBy, orderDirection, title, query, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * List the users that are assigned to a particular role.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:read, me,  
         * @summary List Users Assigned To Role
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersAssignedToRole(roleId: string, options?: any): AxiosPromise<ManyUserRolesOut> {
            return localVarFp.listUsersAssignedToRole(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unassign the role to the specified user.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:create, me,  
         * @summary Unassign Role
         * @param {string} roleId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignRole(roleId: string, userId: string, options?: any): AxiosPromise<UserOut> {
            return localVarFp.unassignRole(roleId, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesAndPermissionsApi - object-oriented interface
 * @export
 * @class RolesAndPermissionsApi
 * @extends {BaseAPI}
 */
export class RolesAndPermissionsApi extends BaseAPI {
    /**
     * Assigns the role to the specified user.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:create, me,  
     * @summary Assign Role
     * @param {string} roleId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesAndPermissionsApi
     */
    public assignRole(roleId: string, userId: string, options?: AxiosRequestConfig) {
        return RolesAndPermissionsApiFp(this.configuration).assignRole(roleId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows an admin to create a role in the system.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:create, me,  
     * @summary Create Role
     * @param {RoleCreate} roleCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesAndPermissionsApi
     */
    public createRole(roleCreate: RoleCreate, options?: AxiosRequestConfig) {
        return RolesAndPermissionsApiFp(this.configuration).createRole(roleCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the role. This endpoint removes the roles from all users that has been previously assigned. The integer returned is the total number of all users the role has been removed from.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:delete, me,  
     * @summary Delete Role
     * @param {string} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesAndPermissionsApi
     */
    public deleteRole(roleId: string, options?: AxiosRequestConfig) {
        return RolesAndPermissionsApiFp(this.configuration).deleteRole(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a single role                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:update, me,  
     * @summary Edit Role
     * @param {string} roleId 
     * @param {BodyEditRoleRolesRoleIdPut} bodyEditRoleRolesRoleIdPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesAndPermissionsApi
     */
    public editRole(roleId: string, bodyEditRoleRolesRoleIdPut: BodyEditRoleRolesRoleIdPut, options?: AxiosRequestConfig) {
        return RolesAndPermissionsApiFp(this.configuration).editRole(roleId, bodyEditRoleRolesRoleIdPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a single role                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:read, me,  
     * @summary Get Role
     * @param {string} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesAndPermissionsApi
     */
    public getRole(roleId: string, options?: AxiosRequestConfig) {
        return RolesAndPermissionsApiFp(this.configuration).getRole(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all the roles in the system                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:read, me,  
     * @summary Get Roles
     * @param {OrderBy} [orderBy] 
     * @param {OrderDirection} [orderDirection] 
     * @param {string} [title] 
     * @param {string} [query] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesAndPermissionsApi
     */
    public getRoles(orderBy?: OrderBy, orderDirection?: OrderDirection, title?: string, query?: string, skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return RolesAndPermissionsApiFp(this.configuration).getRoles(orderBy, orderDirection, title, query, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the users that are assigned to a particular role.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:read, me,  
     * @summary List Users Assigned To Role
     * @param {string} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesAndPermissionsApi
     */
    public listUsersAssignedToRole(roleId: string, options?: AxiosRequestConfig) {
        return RolesAndPermissionsApiFp(this.configuration).listUsersAssignedToRole(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unassign the role to the specified user.                                         <br />                                         <br />                                         <strong>Scopes: </strong> role:create, me,  
     * @summary Unassign Role
     * @param {string} roleId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesAndPermissionsApi
     */
    public unassignRole(roleId: string, userId: string, options?: AxiosRequestConfig) {
        return RolesAndPermissionsApiFp(this.configuration).unassignRole(roleId, userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <strong>Scopes: </strong> me,
         * @summary Admin Change User Password
         * @param {string} userId 
         * @param {ChangePassword} changePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminChangeUserPassword: async (userId: string, changePassword: ChangePassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminChangeUserPassword', 'userId', userId)
            // verify required parameter 'changePassword' is not null or undefined
            assertParamExists('adminChangeUserPassword', 'changePassword', changePassword)
            const localVarPath = `/users/{user_id}/admin-change-user-password`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change User Password
         * @param {ChangePasswordWithToken} changePasswordWithToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPassword: async (changePasswordWithToken: ChangePasswordWithToken, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordWithToken' is not null or undefined
            assertParamExists('changeUserPassword', 'changePasswordWithToken', changePasswordWithToken)
            const localVarPath = `/users/change-user-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordWithToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to create another user in the system. The user is made active if the correct admin-signup-token is provided, and no email will be sent to the user.                                         <br />                                         <br />                                         <strong>Scopes: </strong> user:create, me,  
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {string} [adminSignupToken] The correct admin token to use admin only features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userCreate: UserCreate, adminSignupToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('createUser', 'userCreate', userCreate)
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)

            if (adminSignupToken != null) {
                localVarHeaderParameter['admin-signup-token'] = String(adminSignupToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Download User Photo
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadUserPhoto: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('downloadUserPhoto', 'userId', userId)
            const localVarPath = `/users/{user_id}/download-photo`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>Scopes: </strong> me,                                         <br />                                         <br />                                         <strong>Scopes: </strong> me, 
         * @summary List Scopes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScopes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/list-scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me", "me"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('readUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Read Users
         * @param {string} [query] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsers: async (query?: string, skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Password Change
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordChange: async (email: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('requestPasswordChange', 'email', email)
            const localVarPath = `/users/request-password-change`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email to the user on how to access their account again.
         * @summary Resend Invite
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendInvite: async (email: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('resendInvite', 'email', email)
            const localVarPath = `/users/resend-invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Update User
         * @param {string} userId 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, userUpdate: UserUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('updateUser', 'userUpdate', userUpdate)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Upload User Photo
         * @param {string} userId 
         * @param {File} fileToUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadUserPhoto: async (userId: string, fileToUpload: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('uploadUserPhoto', 'userId', userId)
            // verify required parameter 'fileToUpload' is not null or undefined
            assertParamExists('uploadUserPhoto', 'fileToUpload', fileToUpload)
            const localVarPath = `/users/{user_id}/upload-photo`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["me"], configuration)


            if (fileToUpload !== undefined) { 
                localVarFormParams.append('file_to_upload', fileToUpload as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * <strong>Scopes: </strong> me,
         * @summary Admin Change User Password
         * @param {string} userId 
         * @param {ChangePassword} changePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminChangeUserPassword(userId: string, changePassword: ChangePassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminChangeUserPassword(userId, changePassword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change User Password
         * @param {ChangePasswordWithToken} changePasswordWithToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeUserPassword(changePasswordWithToken: ChangePasswordWithToken, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeUserPassword(changePasswordWithToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows a user to create another user in the system. The user is made active if the correct admin-signup-token is provided, and no email will be sent to the user.                                         <br />                                         <br />                                         <strong>Scopes: </strong> user:create, me,  
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {string} [adminSignupToken] The correct admin token to use admin only features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userCreate: UserCreate, adminSignupToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userCreate, adminSignupToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Download User Photo
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadUserPhoto(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadUserPhoto(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <strong>Scopes: </strong> me,                                         <br />                                         <br />                                         <strong>Scopes: </strong> me, 
         * @summary List Scopes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScopes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManySystemScopeOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScopes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUserMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUserMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Read Users
         * @param {string} [query] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsers(query?: string, skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManyUsersInDB>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsers(query, skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request Password Change
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestPasswordChange(email: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestPasswordChange(email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an email to the user on how to access their account again.
         * @summary Resend Invite
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendInvite(email: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendInvite(email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Update User
         * @param {string} userId 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, userUpdate: UserUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, userUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Upload User Photo
         * @param {string} userId 
         * @param {File} fileToUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadUserPhoto(userId: string, fileToUpload: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadUserPhoto(userId, fileToUpload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * <strong>Scopes: </strong> me,
         * @summary Admin Change User Password
         * @param {string} userId 
         * @param {ChangePassword} changePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminChangeUserPassword(userId: string, changePassword: ChangePassword, options?: any): AxiosPromise<UserOut> {
            return localVarFp.adminChangeUserPassword(userId, changePassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change User Password
         * @param {ChangePasswordWithToken} changePasswordWithToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPassword(changePasswordWithToken: ChangePasswordWithToken, options?: any): AxiosPromise<AppResponseModel> {
            return localVarFp.changeUserPassword(changePasswordWithToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to create another user in the system. The user is made active if the correct admin-signup-token is provided, and no email will be sent to the user.                                         <br />                                         <br />                                         <strong>Scopes: </strong> user:create, me,  
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {string} [adminSignupToken] The correct admin token to use admin only features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userCreate: UserCreate, adminSignupToken?: string, options?: any): AxiosPromise<UserOut> {
            return localVarFp.createUser(userCreate, adminSignupToken, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Download User Photo
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadUserPhoto(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.downloadUserPhoto(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>Scopes: </strong> me,                                         <br />                                         <br />                                         <strong>Scopes: </strong> me, 
         * @summary List Scopes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScopes(options?: any): AxiosPromise<ManySystemScopeOut> {
            return localVarFp.listScopes(options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUser(userId: string, options?: any): AxiosPromise<UserOut> {
            return localVarFp.readUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMe(options?: any): AxiosPromise<UserOut> {
            return localVarFp.readUserMe(options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Read Users
         * @param {string} [query] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsers(query?: string, skip?: number, limit?: number, options?: any): AxiosPromise<ManyUsersInDB> {
            return localVarFp.readUsers(query, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Password Change
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordChange(email: string, options?: any): AxiosPromise<AppResponseModel> {
            return localVarFp.requestPasswordChange(email, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email to the user on how to access their account again.
         * @summary Resend Invite
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendInvite(email: string, options?: any): AxiosPromise<AppResponseModel> {
            return localVarFp.resendInvite(email, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Update User
         * @param {string} userId 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, userUpdate: UserUpdate, options?: any): AxiosPromise<UserOut> {
            return localVarFp.updateUser(userId, userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>Scopes: </strong> me,
         * @summary Upload User Photo
         * @param {string} userId 
         * @param {File} fileToUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadUserPhoto(userId: string, fileToUpload: File, options?: any): AxiosPromise<ProfileOut> {
            return localVarFp.uploadUserPhoto(userId, fileToUpload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * <strong>Scopes: </strong> me,
     * @summary Admin Change User Password
     * @param {string} userId 
     * @param {ChangePassword} changePassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public adminChangeUserPassword(userId: string, changePassword: ChangePassword, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).adminChangeUserPassword(userId, changePassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change User Password
     * @param {ChangePasswordWithToken} changePasswordWithToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changeUserPassword(changePasswordWithToken: ChangePasswordWithToken, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).changeUserPassword(changePasswordWithToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to create another user in the system. The user is made active if the correct admin-signup-token is provided, and no email will be sent to the user.                                         <br />                                         <br />                                         <strong>Scopes: </strong> user:create, me,  
     * @summary Create User
     * @param {UserCreate} userCreate 
     * @param {string} [adminSignupToken] The correct admin token to use admin only features
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(userCreate: UserCreate, adminSignupToken?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(userCreate, adminSignupToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>Scopes: </strong> me,
     * @summary Download User Photo
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public downloadUserPhoto(userId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).downloadUserPhoto(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>Scopes: </strong> me,                                         <br />                                         <br />                                         <strong>Scopes: </strong> me, 
     * @summary List Scopes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listScopes(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listScopes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>Scopes: </strong> me,
     * @summary Read User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUser(userId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).readUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>Scopes: </strong> me,
     * @summary Read User Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUserMe(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).readUserMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>Scopes: </strong> me,
     * @summary Read Users
     * @param {string} [query] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUsers(query?: string, skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).readUsers(query, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Password Change
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public requestPasswordChange(email: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).requestPasswordChange(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an email to the user on how to access their account again.
     * @summary Resend Invite
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resendInvite(email: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).resendInvite(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>Scopes: </strong> me,
     * @summary Update User
     * @param {string} userId 
     * @param {UserUpdate} userUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(userId: string, userUpdate: UserUpdate, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(userId, userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>Scopes: </strong> me,
     * @summary Upload User Photo
     * @param {string} userId 
     * @param {File} fileToUpload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public uploadUserPhoto(userId: string, fileToUpload: File, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).uploadUserPhoto(userId, fileToUpload, options).then((request) => request(this.axios, this.basePath));
    }
}


